// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

generator seed {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
    // Further reading:
    // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
    // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
    url      = env("DATABASE_URL")
}

// User roles enum
enum UserRole {
    ADMIN
    TENANT
}

// Task frequency enum
enum TaskFrequency {
    ONCE           // One-time task
    DAILY          // Every day
    WEEKLY         // Every week
    MONTHLY        // Every month
    CUSTOM         // Custom frequency
}

// Task status enum
enum TaskStatus {
    PENDING
    IN_PROGRESS
    COMPLETED
    OVERDUE
    SKIPPED
}

// Payment status enum
enum PaymentStatus {
    PENDING
    PAID
    OVERDUE
    PARTIAL
}

// Request status enum
enum RequestStatus {
    OPEN
    IN_PROGRESS
    RESOLVED
    CLOSED
}

// User model with role-based authentication
model User {
    id            String    @id @default(cuid())
    name          String?
    email         String?   @unique
    emailVerified DateTime?
    image         String?
    role          UserRole  @default(TENANT)
    phoneNumber   String?
    password      String   // Hashed password for credentials login
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @updatedAt
    
    // Relations
    accounts              Account[]
    sessions              Session[]
    tenantProfile         TenantProfile?
    assignedTasks         TaskAssignment[]
    completedTasks        TaskCompletion[]
    payments              Payment[]
    requests              TenantRequest[]
    createdTasks          Task[]           @relation("TaskCreatedBy")
    createdProperties     Property[]       @relation("PropertyCreatedBy")
    createdRooms          Room[]           @relation("RoomCreatedBy")
    assignedTasksBy       TaskAssignment[] @relation("TaskAssignedBy")
    verifiedTasks         TaskCompletion[] @relation("TaskVerifiedBy")
    respondedRequests     TenantRequest[]  @relation("RequestRespondedBy")

    @@index([email])
    @@index([role])
}

// Tenant-specific profile information
model TenantProfile {
    id              String    @id @default(cuid())
    userId          String    @unique
    propertyId      String
    roomId          String?
    
    // Rent information
    monthlyRent     Decimal   @db.Decimal(10, 2)
    rentDueDay      Int       // Day of month (1-31)
    depositAmount   Decimal?  @db.Decimal(10, 2)
    securityDeposit Decimal?  @db.Decimal(10, 2)
    
    // Personal information
    emergencyContact String?
    emergencyPhone   String?
    moveInDate      DateTime?
    leaseStartDate  DateTime?
    leaseEndDate    DateTime?
    
    // Additional information
    remarks         String?   @db.Text
    notes           String?   @db.Text
    
    createdAt       DateTime  @default(now())
    updatedAt       DateTime  @updatedAt
    
    // Relations
    user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    property        Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)
    room            Room?     @relation(fields: [roomId], references: [id], onDelete: SetNull)

    @@index([propertyId])
    @@index([roomId])
}

// Property management
model Property {
    id          String   @id @default(cuid())
    name        String
    address     String
    description String?  @db.Text
    createdById String
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt
    
    // Relations
    createdBy   User             @relation("PropertyCreatedBy", fields: [createdById], references: [id])
    rooms       Room[]
    tenants     TenantProfile[]
    tasks       Task[]

    @@index([name])
}

// Room/Area management
model Room {
    id          String   @id @default(cuid())
    name        String
    propertyId  String
    description String?  @db.Text
    createdById String
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt
    
    // Relations
    property    Property         @relation(fields: [propertyId], references: [id], onDelete: Cascade)
    createdBy   User             @relation("RoomCreatedBy", fields: [createdById], references: [id])
    tenants     TenantProfile[]
    tasks       Task[]

    @@index([propertyId])
    @@index([name])
}

// Task template/definition
model Task {
    id          String        @id @default(cuid())
    title       String
    description String?       @db.Text
    propertyId  String
    roomId      String?
    
    // Task configuration
    frequency   TaskFrequency @default(ONCE)
    intervalDays Int?         // For custom frequency (e.g., every 3 days)
    estimatedDuration Int?    // In minutes
    priority    Int           @default(1) // 1-5 scale
    
    // Assignment configuration
    assignToAll Boolean       @default(false) // If true, assign to all tenants
    useRotation Boolean       @default(false) // If true, rotate among specific tenants
    maxAssignments Int?       // Maximum number of people who can work on this task
    
    // Metadata
    createdById String
    isActive    Boolean       @default(true)
    createdAt   DateTime      @default(now())
    updatedAt   DateTime      @updatedAt
    
    // Relations
    property    Property          @relation(fields: [propertyId], references: [id], onDelete: Cascade)
    room        Room?             @relation(fields: [roomId], references: [id], onDelete: SetNull)
    createdBy   User              @relation("TaskCreatedBy", fields: [createdById], references: [id])
    assignments TaskAssignment[]
    completions TaskCompletion[]
    recurrences TaskRecurrence[]

    @@index([propertyId])
    @@index([roomId])
    @@index([frequency])
    @@index([isActive])
}

// Task assignments to specific tenants
model TaskAssignment {
    id           String     @id @default(cuid())
    taskId       String
    userId       String
    assignedById String?
    
    // Assignment details
    dueDate      DateTime
    status       TaskStatus @default(PENDING)
    notes        String?    @db.Text
    
    // Recurrence for repetitive tasks
    recurrenceId String?    // Links to recurring task instances
    
    createdAt    DateTime   @default(now())
    updatedAt    DateTime   @updatedAt
    
    // Relations
    task         Task       @relation(fields: [taskId], references: [id], onDelete: Cascade)
    user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
    completions  TaskCompletion[]
    assignedBy   User?      @relation("TaskAssignedBy", fields: [assignedById], references: [id])

    @@index([taskId])
    @@index([userId])
    @@index([dueDate])
    @@index([status])
}

// Task completion tracking
model TaskCompletion {
    id              String     @id @default(cuid())
    taskId          String
    assignmentId    String
    userId          String
    
    // Completion details
    completedAt     DateTime
    status          TaskStatus @default(COMPLETED)
    completionNotes String?    @db.Text
    photos          String[]   // URLs to completion photos
    verifiedBy      String?    // Admin who verified the completion
    verifiedAt      DateTime?
    
    createdAt       DateTime   @default(now())
    updatedAt       DateTime   @updatedAt
    
    // Relations
    task            Task       @relation(fields: [taskId], references: [id], onDelete: Cascade)
    assignment      TaskAssignment @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
    user            User       @relation(fields: [userId], references: [id], onDelete: Cascade)
    verifier        User?      @relation("TaskVerifiedBy", fields: [verifiedBy], references: [id])

    @@index([taskId])
    @@index([userId])
    @@index([completedAt])
    @@index([status])
}

// Payment tracking
model Payment {
    id            String        @id @default(cuid())
    userId        String
    amount        Decimal       @db.Decimal(10, 2)
    paymentType   String        // "rent", "deposit", "fee", etc.
    status        PaymentStatus @default(PENDING)
    dueDate       DateTime
    paidDate      DateTime?
    paymentMethod String?       // "cash", "check", "bank_transfer", etc.
    reference     String?       // Payment reference number
    notes         String?       @db.Text
    
    createdAt     DateTime      @default(now())
    updatedAt     DateTime      @updatedAt
    
    // Relations
    user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([userId])
    @@index([dueDate])
    @@index([status])
}

// Tenant requests and remarks
model TenantRequest {
    id          String        @id @default(cuid())
    userId      String
    title       String
    description String        @db.Text
    requestType String        // "maintenance", "complaint", "general", etc.
    status      RequestStatus @default(OPEN)
    priority    Int           @default(1) // 1-5 scale
    
    // Response tracking
    response    String?       @db.Text
    respondedBy String?       // Admin who responded
    respondedAt DateTime?
    resolvedAt  DateTime?
    
    createdAt   DateTime      @default(now())
    updatedAt   DateTime      @updatedAt
    
    // Relations
    user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
    responder   User?         @relation("RequestRespondedBy", fields: [respondedBy], references: [id])

    @@index([userId])
    @@index([status])
    @@index([requestType])
}

// Task recurrence tracking for repetitive tasks
model TaskRecurrence {
    id          String   @id @default(cuid())
    taskId      String
    baseTaskId  String   // Original task template
    
    // Recurrence details
    nextDueDate DateTime
    isActive    Boolean  @default(true)
    
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt
    
    // Relations
    task        Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)

    @@index([taskId])
    @@index([nextDueDate])
}

// Necessary for Next auth
model Account {
    id                       String  @id @default(cuid())
    userId                   String
    type                     String
    provider                 String
    providerAccountId        String
    refresh_token            String? // @db.Text
    access_token             String? // @db.Text
    expires_at               Int?
    token_type               String?
    scope                    String?
    id_token                 String? // @db.Text
    session_state            String?
    user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
    refresh_token_expires_in Int?

    @@unique([provider, providerAccountId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}
